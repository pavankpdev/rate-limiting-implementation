<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Rate Limiting Demo - Stress Test Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
</head>
<body class="bg-gray-50 min-h-screen text-sm">
  <!-- Stress Test Dashboard -->
  <div class="max-w-6xl mx-auto p-6">
    <!-- Header -->
    <header class="flex items-center justify-between mb-6 gap-4">
      <div>
        <h1 class="text-2xl font-semibold text-gray-800">Rate Limiting Demo â€” Stress Test</h1>
        <p class="text-xs text-gray-600 mt-1">Run concurrent request blasts against the demo endpoints</p>
      </div>

      <div class="flex items-center gap-3">
        <label class="text-xs text-gray-600">Server host</label>
        <input id="host-input" class="border px-3 py-2 rounded w-72" />
      </div>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-3 gap-4">
      <!-- Left: Controls & Summary -->
      <section class="lg:col-span-1 bg-white rounded-lg shadow p-4 space-y-4">
        <form id="control-form" class="space-y-3">
          <div>
            <label class="block text-xs font-medium text-gray-700">Total requests</label>
            <input id="total-requests" type="number" class="w-full border px-3 py-2 rounded" min="1" value="200" />
          </div>

          <div>
            <label class="block text-xs font-medium text-gray-700">Concurrency (per batch)</label>
            <input id="concurrency" type="number" class="w-full border px-3 py-2 rounded" min="1" value="10" />
          </div>

          <div>
            <label class="block text-xs font-medium text-gray-700">Batch delay (ms)</label>
            <input id="batch-delay" type="number" class="w-full border px-3 py-2 rounded" min="0" value="100" />
            <p class="text-xs text-gray-500 mt-1">Small pause between batches to avoid a full firehose</p>
          </div>

          <div class="flex items-center gap-3">
            <input id="use-rate-limited" type="checkbox" checked class="h-4 w-4" />
            <label for="use-rate-limited" class="text-xs text-gray-700">Use rate-limited endpoint</label>
          </div>

          <div class="border-t pt-3">
            <label class="block text-xs font-medium text-gray-700">Auth mode</label>
            <div class="flex gap-2">
              <button id="guest-get" type="button" class="bg-gray-800 text-white px-3 py-1 rounded text-xs">Get Guest ID</button>
              <input id="user-id-input" placeholder="Or paste userId here" class="flex-1 border px-2 py-1 rounded text-xs" />
            </div>
            <p id="auth-hint" class="text-xs text-gray-500 mt-1">Guest will POST /auth/guest to obtain a userId</p>
          </div>

          <div class="flex items-center gap-2 mt-2">
            <button id="start-btn" type="button" class="flex-1 bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">Start</button>
            <button id="stop-btn" type="button" class="flex-1 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600">Stop</button>
          </div>

          <div class="flex items-center gap-2">
            <button id="export-btn" type="button" class="flex-1 bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700">Export logs (JSON)</button>
            <button id="clear-btn" type="button" class="flex-1 bg-gray-200 text-gray-700 px-4 py-2 rounded hover:bg-gray-300">Clear</button>
          </div>
        </form>

        <!-- Summary -->
        <div class="border-t pt-3">
          <h3 class="text-xs font-medium text-gray-700 mb-2">Summary</h3>
          <div class="grid grid-cols-2 gap-2 text-xs">
            <div class="text-gray-600">Total sent</div><div id="sum-total-sent" class="font-medium text-gray-800">0</div>
            <div class="text-gray-600">Completed</div><div id="sum-completed" class="font-medium text-gray-800">0</div>
            <div class="text-gray-600">OK</div><div id="sum-ok" class="font-medium text-green-600">0</div>
            <div class="text-gray-600">Rate limited</div><div id="sum-rate-limited" class="font-medium text-orange-600">0</div>
            <div class="text-gray-600">Timeouts</div><div id="sum-timeouts" class="font-medium text-red-600">0</div>
            <div class="text-gray-600">Errors</div><div id="sum-errors" class="font-medium text-red-800">0</div>
            <div class="text-gray-600">Avg latency</div><div id="sum-avg-latency" class="font-medium text-gray-800">0ms</div>
          </div>
        </div>

        <!-- Live server metrics -->
        <div class="border-t pt-3">
          <h3 class="text-xs font-medium text-gray-700 mb-2">Server metrics (live)</h3>
          <div class="text-xs text-gray-600">
            Active workers: <span id="metric-active-workers">0</span><br/>
            Queue length: <span id="metric-queue-length">0</span>
          </div>
        </div>
      </section>

      <!-- Middle: Logs (main) -->
      <section class="lg:col-span-2 bg-white rounded-lg shadow p-4 flex flex-col">
        <div class="flex items-center justify-between mb-3">
          <div class="text-xs text-gray-700 font-medium">Live Logs (latest first)</div>
          <div class="text-xs text-gray-500">Showing up to 1000 latest entries</div>
        </div>

        <div id="logs-container" class="flex-1 overflow-auto border rounded p-2 space-y-2 bg-gray-50" style="min-height:420px; max-height:72vh;">
          <!-- entries inserted here -->
        </div>

        <div class="mt-3 text-xs text-gray-500">Click an entry to expand rawBody</div>
      </section>
    </main>
  </div>

  <script>
    /*
      In-browser stress test runner.
      - Single-file implementation inside public/index.html (demo)
      - Keep logs capped in DOM to 1000 entries but retain all logs in memory for export
      - Uses fetch + AbortController & per-request client timeout
      - Polls /metrics for server metrics
      - No external deps beyond Tailwind (already included)
    */

    // -----------------------------
    // Local state
    // -----------------------------
    const state = {
      host: window.location.origin,
      userId: '',
      isAuthenticated: false,
      running: false,
      stopRequested: false,
      nextLogId: 1,
      fullLogs: [],            // full logs (export)
      displayedCountCap: 1000, // cap DOM nodes
      controllers: new Set(),  // active AbortControllers
      clientTimeoutMs: 15000,  // per-request client timeout default (15s)
      stats: {
        totalSent: 0,
        completed: 0,
        ok: 0,
        rate_limited: 0,
        timeout: 0,
        error: 0,
        totalLatencyMs: 0
      }
    };

    // -----------------------------
    // DOM references
    // -----------------------------
    const hostInput = document.getElementById('host-input');
    const totalRequestsInput = document.getElementById('total-requests');
    const concurrencyInput = document.getElementById('concurrency');
    const batchDelayInput = document.getElementById('batch-delay');
    const useRateLimitedInput = document.getElementById('use-rate-limited');
    const guestGetBtn = document.getElementById('guest-get');
    const userIdInput = document.getElementById('user-id-input');
    const startBtn = document.getElementById('start-btn');
    const stopBtn = document.getElementById('stop-btn');
    const exportBtn = document.getElementById('export-btn');
    const clearBtn = document.getElementById('clear-btn');

    const logsContainer = document.getElementById('logs-container');

    const sumTotalSent = document.getElementById('sum-total-sent');
    const sumCompleted = document.getElementById('sum-completed');
    const sumOk = document.getElementById('sum-ok');
    const sumRateLimited = document.getElementById('sum-rate-limited');
    const sumTimeouts = document.getElementById('sum-timeouts');
    const sumErrors = document.getElementById('sum-errors');
    const sumAvgLatency = document.getElementById('sum-avg-latency');

    const metricActiveWorkers = document.getElementById('metric-active-workers');
    const metricQueueLength = document.getElementById('metric-queue-length');

    // initialize host input
    hostInput.value = state.host;

    // -----------------------------
    // Utility helpers
    // -----------------------------
    function safeJsonParse(text) {
      try { return JSON.parse(text); } catch(e) { return null; }
    }

    function nowMs() { return performance.now(); }

    function isoNow() { return new Date().toISOString(); }

    function downloadJSON(filename, data) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // -----------------------------
    // Log handling & rendering
    // -----------------------------
    function createLogEntry({ endpoint, status, httpStatus, elapsedMs, shortMessage, rawBody }) {
      const id = state.nextLogId++;
      const entry = {
        id,
        endpoint,
        status,
        httpStatus: httpStatus || 0,
        elapsedMs: Math.round(elapsedMs),
        shortMessage: shortMessage || '',
        rawBody: rawBody === undefined ? null : rawBody,
        timestamp: isoNow()
      };
      // store full log
      state.fullLogs.push(entry);
      // update stats
      state.stats.totalSent++;
      if (status === 'ok') state.stats.ok++;
      else if (status === 'rate_limited') state.stats.rate_limited++;
      else if (status === 'timeout') state.stats.timeout++;
      else if (status === 'server_overloaded') state.stats.rate_limited++;
      else state.stats.error++;

      state.stats.completed++;
      state.stats.totalLatencyMs += entry.elapsedMs || 0;

      // render in DOM (prepend latest)
      prependLogToDOM(entry);
      updateSummary();
      return entry;
    }

    function updateSummary() {
      sumTotalSent.textContent = String(state.stats.totalSent);
      sumCompleted.textContent = String(state.stats.completed);
      sumOk.textContent = String(state.stats.ok);
      sumRateLimited.textContent = String(state.stats.rate_limited);
      sumTimeouts.textContent = String(state.stats.timeout);
      sumErrors.textContent = String(state.stats.error);
      const avg = state.stats.completed ? Math.round(state.stats.totalLatencyMs / state.stats.completed) : 0;
      sumAvgLatency.textContent = `${avg}ms`;
    }

    function colorForStatus(status) {
      if (status === 'ok') return 'bg-green-50 border-green-200 text-green-800';
      if (status === 'rate_limited') return 'bg-yellow-50 border-yellow-200 text-yellow-800';
      if (status === 'server_overloaded') return 'bg-orange-50 border-orange-200 text-orange-800';
      if (status === 'timeout') return 'bg-red-50 border-red-200 text-red-800';
      return 'bg-gray-50 border-gray-200 text-gray-800';
    }

    function prependLogToDOM(entry) {
      const el = document.createElement('div');
      el.className = `border rounded p-2 flex flex-col ${colorForStatus(entry.status)}`;
      el.style.cursor = 'pointer';
      el.dataset.logId = String(entry.id);

      el.innerHTML = `
        <div class="flex items-center justify-between gap-2">
          <div class="flex items-center gap-3">
            <div class="text-xs font-semibold">${entry.id}</div>
            <div class="text-xs text-gray-600">${entry.endpoint}</div>
            <div class="text-xs font-medium">${entry.shortMessage}</div>
          </div>
          <div class="text-xs text-gray-600">${entry.elapsedMs}ms</div>
        </div>
        <div class="text-xs text-gray-500 mt-2 hidden raw-body" style="white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, 'Roboto Mono', monospace; max-height: 220px; overflow:auto"></div>
      `;

      const rawDiv = el.querySelector('.raw-body');
      if (entry.rawBody) {
        try { rawDiv.textContent = typeof entry.rawBody === 'string' ? entry.rawBody : JSON.stringify(entry.rawBody, null, 2); }
        catch (_) { rawDiv.textContent = String(entry.rawBody); }
      } else {
        rawDiv.textContent = '';
      }

      el.addEventListener('click', () => {
        if (rawDiv.classList.contains('hidden')) rawDiv.classList.remove('hidden'); else rawDiv.classList.add('hidden');
      });

      // prepend to container
      logsContainer.prepend(el);

      // cap DOM children to latest N
      while (logsContainer.children.length > state.displayedCountCap) {
        logsContainer.removeChild(logsContainer.lastChild);
      }
    }

    function clearLogs() {
      state.fullLogs = [];
      state.nextLogId = 1;
      state.stats = {
        totalSent: 0,
        completed: 0,
        ok: 0,
        rate_limited: 0,
        timeout: 0,
        error: 0,
        totalLatencyMs: 0
      };
      logsContainer.innerHTML = '';
      updateSummary();
    }

    // -----------------------------
    // Metrics polling
    // -----------------------------
    async function pollMetrics() {
      try {
        const res = await fetch(new URL('/metrics', hostInput.value).toString(), { method: 'GET' });
        const data = await res.json();
        metricActiveWorkers.textContent = String(data.activeWorkers || 0);
        metricQueueLength.textContent = String(data.queueLength || 0);
      } catch (e) {
        // ignore
      }
    }
    setInterval(pollMetrics, 1000);
    pollMetrics();

    // -----------------------------
    // Request runner implementation
    // -----------------------------
    async function obtainGuestUserId() {
      try {
        const res = await fetch(new URL('/auth/guest', hostInput.value).toString(), { method: 'POST', headers: { 'Content-Type': 'application/json' } });
        const data = await res.json();
        if (data && data.userId) {
          state.userId = data.userId;
          state.isAuthenticated = data.isAuthenticated || false;
          userIdInput.value = state.userId;
        } else {
          throw new Error('Invalid guest response');
        }
      } catch (e) {
        alert('Failed to obtain guest id: ' + (e && e.message));
      }
    }

    // parse server response & categorize status according to rules
    async function parseResponseStatus(res, elapsedMs) {
      let bodyText = null;
      let parsed = null;
      try {
        const text = await res.text();
        bodyText = text;
        parsed = safeJsonParse(text);
      } catch (e) {
        // ignore
      }
      let status = 'error';
      const httpStatus = res.status || 0;
      const bodyStr = JSON.stringify(parsed || bodyText || '');
      // rules:
      if (httpStatus >= 200 && httpStatus <= 299) {
        status = 'ok';
      } else if (httpStatus === 408) {
        status = 'timeout';
      } else if (httpStatus === 429) {
        const msg = (parsed && (parsed.error || parsed.message)) || bodyText || '';
        if (/server overloaded/i.test(msg) || /overload/i.test(msg)) status = 'server_overloaded';
        else status = 'rate_limited';
      } else {
        status = 'error';
      }

      const shortMessage = (parsed && (parsed.error || parsed.message)) || res.statusText || `HTTP ${httpStatus}`;

      return { status, httpStatus, elapsedMs, shortMessage, rawBody: parsed || bodyText || null };
    }

    function makeRequestWithTimeout(url, init, timeoutMs = 15000) {
      const controller = new AbortController();
      init.signal = controller.signal;
      const timeout = setTimeout(() => controller.abort(), timeoutMs);
      state.controllers.add(controller);
      const promise = fetch(url, init)
        .then(async (res) => {
          clearTimeout(timeout);
          state.controllers.delete(controller);
          return res;
        })
        .catch((err) => {
          clearTimeout(timeout);
          state.controllers.delete(controller);
          throw err;
        });
      // return both controller and the promise
      return { controller, promise };
    }

    async function runStressTest({ total, concurrency, batchDelay, useRateLimited }) {
      if (!state.userId) {
        // if user pasted id, use that
        if (userIdInput.value && userIdInput.value.trim()) {
          state.userId = userIdInput.value.trim();
          state.isAuthenticated = false;
        } else {
          // try to obtain guest
          await obtainGuestUserId();
          if (!state.userId) {
            alert('No userId available; aborting');
            return;
          }
        }
      }

      state.running = true;
      state.stopRequested = false;

      const host = hostInput.value || window.location.origin;
      const endpointPath = useRateLimited ? '/chat/with-rate-limit' : '/chat/without-rate-limit';
      const url = new URL(endpointPath, host).toString();

      // Prepare payload
      const basePayload = useRateLimited
        ? { userId: state.userId, isAuthenticated: state.isAuthenticated, message: 'ui blast' }
        : { userId: state.userId, message: 'ui blast' };

      // iterate batches
      let sentCount = 0;
      while (sentCount < total && !state.stopRequested) {
        const batchSize = Math.min(concurrency, total - sentCount);
        const batchPromises = [];
        for (let i = 0; i < batchSize; i++) {
          const idForLog = state.nextLogId;
          const payload = JSON.stringify(basePayload);
          const init = { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: payload };
          const start = nowMs();
          const { controller, promise } = makeRequestWithTimeout(url, init, state.clientTimeoutMs);
          // handle outcome
          const wrapped = promise
            .then(async (res) => {
              const elapsed = nowMs() - start;
              const parsed = await parseResponseStatus(res, elapsed);
              createLogEntry({
                endpoint: useRateLimited ? 'with-rate-limit' : 'without-rate-limit',
                status: parsed.status,
                httpStatus: parsed.httpStatus,
                elapsedMs: parsed.elapsedMs,
                shortMessage: parsed.shortMessage,
                rawBody: parsed.rawBody
              });
            })
            .catch((err) => {
              const elapsed = nowMs() - start;
              // fetch may have been aborted (signal), treat as timeout
              const isAbort = err && err.name === 'AbortError';
              createLogEntry({
                endpoint: useRateLimited ? 'with-rate-limit' : 'without-rate-limit',
                status: isAbort ? 'timeout' : 'error',
                httpStatus: 0,
                elapsedMs: elapsed,
                shortMessage: isAbort ? 'Request aborted/timeout' : (err && err.message) || 'Network error',
                rawBody: null
              });
            });
          batchPromises.push(wrapped);
        }
        // wait for batch to complete
        await Promise.all(batchPromises);

        sentCount += batchSize;

        // small delay between batches
        if (batchDelay > 0 && sentCount < total && !state.stopRequested) {
          await new Promise((res) => setTimeout(res, batchDelay));
        }
      }

      state.running = false;
      state.stopRequested = false;
    }

    // -----------------------------
    // Control handlers
    // -----------------------------
    startBtn.addEventListener('click', async () => {
      if (state.running) {
        alert('A test is already running. Stop first.');
        return;
      }
      // reset summary but keep full logs unless user cleared
      // optional: clear summary counters but keep logs; easier to reset counters
      state.stats = {
        totalSent: 0,
        completed: 0,
        ok: 0,
        rate_limited: 0,
        timeout: 0,
        error: 0,
        totalLatencyMs: 0
      };
      updateSummary();

      const total = Math.max(1, parseInt(totalRequestsInput.value, 10) || 1);
      const concurrency = Math.max(1, parseInt(concurrencyInput.value, 10) || 1);
      const batchDelay = Math.max(0, parseInt(batchDelayInput.value, 10) || 0);
      const useRateLimited = useRateLimitedInput.checked;

      // run in background
      runStressTest({ total, concurrency, batchDelay, useRateLimited })
        .then(() => {
          // finished normally
          // leave logs for export
        })
        .catch((e) => {
          console.error('Stress test error', e);
        });
    });

    stopBtn.addEventListener('click', () => {
      if (!state.running) return;
      state.stopRequested = true;
      // abort all controllers
      state.controllers.forEach((c) => {
        try { c.abort(); } catch (e) {}
      });
      state.controllers.clear();
      state.running = false;
    });

    guestGetBtn.addEventListener('click', async () => {
      guestGetBtn.disabled = true;
      await obtainGuestUserId();
      guestGetBtn.disabled = false;
    });

    exportBtn.addEventListener('click', () => {
      const filename = `stress-logs-${new Date().toISOString().replace(/[:.]/g,'-')}.json`;
      downloadJSON(filename, state.fullLogs);
    });

    clearBtn.addEventListener('click', () => {
      if (!confirm('Clear logs (keeps current userId)?')) return;
      clearLogs();
    });

    // update host input from page origin when changed
    hostInput.addEventListener('change', () => {
      try { new URL(hostInput.value); } catch (e) { hostInput.value = window.location.origin; }
    });

    // if user manually pastes userId, update state
    userIdInput.addEventListener('change', () => {
      const v = userIdInput.value && userIdInput.value.trim();
      if (v) {
        state.userId = v;
        state.isAuthenticated = false;
      }
    });

    // initialize small demo state
    userIdInput.value = state.userId || '';
  </script>
</body>
</html>